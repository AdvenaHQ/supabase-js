{
  "version": 3,
  "sources": ["../../../src/helpers/parseOptions.ts"],
  "sourcesContent": ["import { DEFAULT_HEADERS } from \"@supabase/supabase-js/dist/module/lib/constants\";\nimport { z } from \"zod\";\nimport { log } from \"../helpers/log\";\nimport { RedisCacheProviderFetch } from \"../server/cache-providers/ioredis\";\nimport { SupacacheCacheProviderFetch } from \"../server/cache-providers/supacache\";\nimport { UpstashCacheProviderFetch } from \"../server/cache-providers/upstash\";\nimport type { ParseOptionsReturnType, UseSupabaseOptions } from \"../types\";\nimport { VERSION } from \"../version\";\nimport { deepMerge } from \"./deepMerge\";\n\n/**\n * Default options for the Supabase client constructor.\n */\nconst defaultOptions: UseSupabaseOptions = {\n    cache: undefined,\n    config: {\n        db: {\n            schema: \"public\",\n        },\n        global: {\n            headers: {\n                \"X-Client-Info\": [\n                    // Extract the Supabase client/platform info from the default headers\n                    ...`${DEFAULT_HEADERS[\"X-Client-Info\"]}`.split(\",\"),\n                    // Add the @advena/supabase package version to the client info\n                    `advena-supabase/${VERSION}`,\n                ]\n                    // Remove any leading/trailing whitespace from the client info\n                    .map((item) => item.trim())\n                    // Remove any empty items from the client info\n                    .filter((item) => item.trim() !== \"\")\n                    // Join the client info items back together\n                    .join(\", \"),\n            },\n        },\n    },\n    role: \"anon\",\n    supabaseUrl: process?.env?.UPV_SECRETS_SUPABASE_URL || \"\",\n    auth: {\n        keys: {\n            secret: process?.env\n                ?.UPV_SECRETS_SUPABASE_SERVICEROLE_KEY as string,\n            publishable: process?.env?.UPV_SECRETS_SUPABASE_ANON_KEY as string,\n        },\n    },\n};\n\n/**\n * Parses and validates the user-provided options for initializing the Supabase client.\n *\n * This function merges the user options with the default options and performs various\n * validations to ensure that the necessary configurations are provided and valid.\n *\n * @param userOptions - The user-provided options for initializing the Supabase client.\n * @param defaults - The default options for initializing the Supabase client.\n * @param context - The context in which the options are being parsed. This can be either \"server\" or \"browser\".\n *\n * @returns The validated and merged options.\n *\n * @throws Will throw an error if the required configurations are missing or invalid.\n */\nexport const parseOptions = (\n    userOptions: UseSupabaseOptions | undefined,\n    defaults?: UseSupabaseOptions,\n    context: \"server\" | \"browser\" = \"server\",\n): ParseOptionsReturnType => {\n    // If a default options object is not provided, use the default options\n    // biome-ignore lint/style/noParameterAssign: We need to assign the default options if they are not provided\n    defaults = defaults || defaultOptions;\n\n    // Merge the user options with the default options to start with\n    let options = deepMerge(defaults, userOptions || {});\n\n    /************************ Validate default options *************************/\n    // First, check that the default options are present and valid\n    if (\n        !options.supabaseUrl ||\n        z.string().url().safeParse(options?.supabaseUrl)?.error\n    )\n        log(\n            `You must provide a valid Supabase URL when initialising the client. Expected a URL but received: \\`(${typeof options?.supabaseUrl}) ${options?.supabaseUrl}\\` instead.`,\n            \"error\",\n            true, // Throw an error\n            false, // Log in all environments (including production)\n        );\n\n    // Parse and configure cache providers\n    if (userOptions?.cache?.provider !== undefined)\n        options = parseCacheProvider({ userOptions, options, context });\n\n    // Now, let's determine the authentication settings that need to be used\n    if (\n        userOptions?.auth?.useToken &&\n        (userOptions?.auth?.useToken as string).toString().trim() !== \"\"\n    ) {\n        // The user has provided a token. We will configure the Supabase client instance to use that and drop the conflicting options\n        // First, drop the key values from the options\n        options = {\n            ...options,\n            // Drop the role from the options\n            role: undefined,\n            config: {\n                ...options?.config,\n                global: {\n                    ...options?.config?.global,\n                    headers: {\n                        ...options?.config?.global?.headers,\n\n                        // Set the token as the Authorization header\n                        Authorization: `Bearer ${userOptions.auth.useToken}`,\n                    },\n                },\n            },\n            auth: {\n                ...options.auth,\n                // Drop the conflicting keys from the options\n                keys: {\n                    secret: undefined,\n                    publishable: undefined,\n                },\n            },\n        };\n    } else {\n        // The user has not provided a token. We will use the keys provided in the options.\n        // We need to verify that the keys are provided in the options. If not, we will use the default keys (or throw)\n        // Check the secret key\n        if (\n            !options?.auth?.keys?.secret ||\n            z.string().min(1).safeParse(options?.auth?.keys?.secret)?.error\n        )\n            log(\n                `You must configure a valid Supabase Secret Key (auth.keys.secret) or RLS Token (auth.useToken) when initialising the client, or set the \\`UPV_SECRETS_SUPABASE_SERVICEROLE_KEY\\` environment variable. Expected a secret key as a string but received: \\`(${typeof options?.auth?.keys?.secret}) ${options?.auth?.keys?.secret}\\` instead. No default key was found and \\`auth.useToken\\` is not set.`,\n                \"error\",\n                true, // Throw an error\n                false, // Log in all environments (including production)\n            );\n\n        // Check the publishable key\n        if (\n            !options?.auth?.keys?.publishable ||\n            z.string().min(1).safeParse(options?.auth?.keys?.publishable)?.error\n        )\n            log(\n                `You must configure a valid Supabase Publishable Key (auth.keys.publishable) or RLS Token (auth.useToken) when initialising the client, or set the \\`UPV_SECRETS_SUPABASE_ANON_KEY\\` environment variable. Expected a publishable key as a string but received: \\`(${typeof options?.auth?.keys?.publishable}) ${options?.auth?.keys?.publishable}\\` instead. No default key was found and \\`auth.useToken\\` is not set.`,\n                \"error\",\n                true, // Throw an error\n                false, // Log in all environments (including production)\n            );\n\n        // Check the role\n        if (!options?.role)\n            log(\n                `You must configure a valid Supabase role when initialising the client, or RLS Token (auth.useToken). Expected a role as a string but received: \\`(${typeof options?.role}) ${options?.role}\\` instead.`,\n                \"error\",\n                true, // Throw an error\n                false, // Log in all environments (including production)\n            );\n\n        // Make sure that we're not trying to use a server role in the browser\n        if (context === \"browser\" && options?.role === \"service_role\") {\n            log(\n                \"useSupabase was called requesting the Service Role in the browser context. This is not allowed as it would expose your secret key. The client was automatically configured to use the Anon Role instead.\",\n                \"warn\",\n                false, // Throw an error\n                false, // Log in all environments (including production)\n            );\n\n            // Set the role to \"anon\" to prevent exposing the secret key\n            options = {\n                ...options,\n                role: \"anon\",\n            };\n        }\n    }\n\n    // If we're in the browser context, scrub all sensitive values from the options\n    if (context === \"browser\") {\n        // Scrub the secret key\n        options = {\n            ...options,\n            cache: undefined,\n            auth: {\n                ...options.auth,\n                keys: {\n                    ...options.auth?.keys,\n                    secret: undefined,\n                },\n            },\n        };\n    }\n\n    // Return the validated options\n    return {\n        options,\n        authStrategy: userOptions?.auth?.useToken ? \"jwt\" : \"key\",\n    };\n};\n\n/**\n * Parses and configures the cache provider options for Supabase.\n *\n * This function validates and sets up the cache provider based on the user-provided options.\n * It supports supacache, Upstash Redis, and ioredis as cache providers and ensures that the\n * necessary configuration options are provided and valid.\n *\n * @param {Object} params - The parameters for configuring the cache provider.\n * @param {UseSupabaseOptions | undefined} params.userOptions - The user-provided options for configuring Supabase.\n * @param {UseSupabaseOptions} params.options - The default options for configuring Supabase.\n * @param {\"server\" | \"browser\"} [params.context=\"server\"] - The context in which the cache provider is being configured.\n * @returns {UseSupabaseOptions} The updated options with the configured cache provider.\n *\n * @throws Will throw an error if the necessary configuration options for the selected cache provider are not provided or invalid.\n */\nconst parseCacheProvider = ({\n    userOptions,\n    options,\n    context = \"server\",\n}: {\n    userOptions: UseSupabaseOptions | undefined;\n    options: UseSupabaseOptions;\n    context: \"server\" | \"browser\";\n}): UseSupabaseOptions => {\n    /**\n     * Configures the cache provider to use Upstash Redis and validates the necessary options.\n     *\n     * @returns {UseSupabaseOptions} The updated options with Upstash Redis configured as the cache provider.\n     */\n    const useUpstashRedis = (): UseSupabaseOptions => {\n        // Do a type check on the provider to force type narrowing\n        if (userOptions?.cache?.provider !== \"upstash-redis\")\n            return options as UseSupabaseOptions;\n\n        // The user has selected Upstash as the cache provider. We need to ensure that the Upstash URL is provided\n        if (\n            !userOptions?.cache?.upstash?.url ||\n            z.string().url().safeParse(userOptions?.cache?.upstash?.url)?.error\n        )\n            log(\n                `You must provide a valid Upstash URL (\\`cache.upstash.url\\`) when using Upstash as the cache provider. Expected a URL but received: \\`(${typeof userOptions?.cache?.upstash?.url}) ${userOptions?.cache?.upstash?.url}\\` instead.`,\n                \"error\",\n                true, // Throw an error\n                false, // Log in all environments (including production)\n            );\n\n        // Check that the Upstash token is provided\n        if (\n            !userOptions?.cache?.upstash?.token ||\n            z.string().min(1).safeParse(userOptions?.cache?.upstash?.token)\n                ?.error\n        )\n            log(\n                `You must provide a valid Upstash token (\\`cache.upstash.token\\`) when using Upstash as the cache provider. Expected a string but received: \\`(${typeof userOptions?.cache?.upstash?.token}) ${userOptions?.cache?.upstash?.token}\\` instead.`,\n                \"error\",\n                true, // Throw an error\n                false, // Log in all environments (including production)\n            );\n\n        // Configure the cache provider in the options\n        options = {\n            ...options,\n            cache: {\n                ...options?.cache,\n                // Set the cache provider to Upstash\n                provider: \"upstash-redis\",\n\n                // Merge the user options with the default options\n                upstash: {\n                    // Spread the user configuration options for Upstash\n                    ...userOptions?.cache?.upstash,\n\n                    // Set the default Upstash URL and token if not provided\n                    url: (userOptions?.cache?.upstash?.url as string) || \"\",\n                    token: (userOptions?.cache?.upstash?.token as string) || \"\",\n\n                    // Set the default Upstash cache behaviour options if not provided\n                    behaviour: {\n                        // Set the default expiry time for the cache\n                        expireSetAfter:\n                            (userOptions?.cache?.upstash\n                                ?.behaviour as number) || undefined,\n                    },\n                },\n            },\n            config: {\n                ...options?.config,\n                global: {\n                    ...options?.config?.global,\n                    fetch: UpstashCacheProviderFetch,\n                },\n            },\n        };\n\n        // Return the happy options\n        return options;\n    };\n\n    /**\n     * Configures the cache provider to use Redis (Node-Redis) and validates the Redis Connection URL.\n     *\n     * @returns {UseSupabaseOptions} The updated options with Redis as the cache provider.\n     */\n    const useNodeRedis = (): UseSupabaseOptions => {\n        // Do a type check on the provider to force type narrowing\n        if (userOptions?.cache?.provider !== \"ioredis\")\n            return options as UseSupabaseOptions;\n\n        // The user has selected Upstash as the cache provider. We need to ensure that the Redis Connection URL is provided\n        if (\n            !userOptions?.cache?.ioredis?.url ||\n            z\n                .string()\n                .startsWith(\"redis://\")\n                .safeParse(userOptions?.cache?.ioredis?.url)?.error\n        )\n            log(\n                `You must provide a valid Redis Connection URL (\\`cache.ioredis.url\\`) when using Redis (ioredis) as the cache provider. Expected a URL starting with \"redis://\" but received: \\`(${typeof userOptions?.cache?.ioredis?.url}) ${userOptions?.cache?.ioredis?.url}\\` instead.`,\n                \"error\",\n                true, // Throw an error\n                false, // Log in all environments (including production)\n            );\n\n        // Configure the cache provider in the options\n        options = {\n            ...options,\n            cache: {\n                ...options?.cache,\n                // Set the cache provider to Redis\n                provider: \"ioredis\",\n\n                // Merge the user options with the default options\n                ioredis: {\n                    // Set the default Redis URL and token if not provided\n                    url:\n                        (userOptions?.cache?.ioredis?.url as string) ||\n                        (process.env\n                            .SECRETS_SUPABASE_REDISCACHE_URL as string) ||\n                        \"\",\n                },\n            },\n            config: {\n                ...options?.config,\n                global: {\n                    ...options?.config?.global,\n                    fetch: RedisCacheProviderFetch,\n                },\n            },\n        };\n\n        // Return the happy options\n        return options;\n    };\n\n    /**\n     * Configures the cache provider to use Supacache and validates the necessary options.\n     *\n     * @returns {UseSupabaseOptions} The updated options with Redis as the cache provider.\n     */\n    const useSupacache = (): UseSupabaseOptions => {\n        // Do a type check on the provider to force type narrowing\n        if (userOptions?.cache?.provider !== \"supacache\")\n            return options as UseSupabaseOptions;\n\n        // The user has selected Supacache as the cache provider. We need to ensure that the Supacache URL is provided\n        if (\n            !userOptions?.cache?.supacache?.url ||\n            z\n                .string()\n                .url()\n                .startsWith(\"https://\")\n                .safeParse(userOptions?.cache?.supacache?.url)?.error\n        )\n            log(\n                `You must provide a valid Supacache Middleware Worker URL (\\`cache.supacache.url\\`) when using Supacache as the cache provider. Expected a valid URL starting with \"https://\" but received: \\`(${typeof userOptions?.cache?.supacache?.url}) ${userOptions?.cache?.supacache?.url}\\` instead.`,\n                \"error\",\n                true, // Throw an error\n                false, // Log in all environments (including production)\n            );\n\n        // We should also ensure that the Supacache service key is provided. If it's not, we'll warn the user that this is not secure\n        if (\n            !userOptions?.cache?.supacache?.serviceKey ||\n            z\n                .string()\n                .min(1)\n                .safeParse(userOptions?.cache?.supacache?.serviceKey)?.error\n        )\n            log(\n                \"\u26A0\uFE0F Supabase is configured to use supacache as the cache provider, but a supacache service key was not provided. This is not secure and may expose your cache to unauthorized access. Please review the documentation at https://github.com/AdvenaHQ/supacache?tab=readme-ov-file#%EF%B8%8F-setup for instructions on how to do this.\",\n                \"warn\",\n                false, // Don't throw an error\n                true, // Don't log in production environments (we don't want to pollute the logs)\n            );\n\n        // Configure the cache provider in the options\n        options = {\n            ...options,\n            cache: {\n                ...options?.cache,\n                // Set the cache provider to Supacache\n                provider: \"supacache\",\n\n                // Merge the user options with the default options\n                supacache: {\n                    // Set the default Redis URL and token if not provided\n                    url:\n                        (userOptions?.cache?.supacache?.url as string) ||\n                        (process.env\n                            .SECRETS_SUPABASE_SUPACACHE_URL as string) ||\n                        \"\",\n\n                    // Set the default Supacache service key if not provided\n                    serviceKey:\n                        (userOptions?.cache?.supacache?.serviceKey as string) ||\n                        (process.env\n                            .SECRETS_SUPABASE_SUPACACHE_SERVICE_KEY as string) ||\n                        undefined,\n                },\n            },\n            config: {\n                ...options?.config,\n                global: {\n                    ...options?.config?.global,\n                    fetch: SupacacheCacheProviderFetch,\n                },\n            },\n        };\n\n        // Return the happy options\n        return options;\n    };\n\n    // Make sure the context is server\n    if (context !== \"server\") {\n        // Drop the cache provider settings from the config (caching can only be used in server contexts)\n        options.cache = undefined;\n\n        // Log that we're not using the cache\n        log(\n            `The client was initialised with a cache provider, but the context is ${context}. Caching is only available in server contexts. Caching was automatically disabled to prevent errors.`,\n            \"info\",\n        );\n\n        // Return the options\n        return options;\n    }\n\n    // Use supacache as the configuration parser provider\n    if (userOptions?.cache?.provider === \"supacache\") options = useSupacache();\n\n    // Use Upstash Redis as the configuration parser provider\n    if (userOptions?.cache?.provider === \"upstash-redis\")\n        options = useUpstashRedis();\n\n    // Use Upstash Redis as the configuration parser provider\n    if (userOptions?.cache?.provider === \"ioredis\") options = useNodeRedis();\n\n    // Return the parsed cache provider options\n    return options;\n};\n"],
  "mappings": "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",
  "names": ["constants_1", "zod_1", "log_1", "ioredis_1", "supacache_1", "upstash_1", "version_1", "deepMerge_1", "defaultOptions", "item", "parseOptions", "userOptions", "defaults", "context", "options", "parseCacheProvider", "useUpstashRedis", "useNodeRedis", "useSupacache"]
}
