{
  "version": 3,
  "sources": ["../../../src/server/extend.ts"],
  "sourcesContent": ["import type {\n    ExtendedQueryBuilder,\n    ExtendedSupabaseClient,\n    GenericRelationship,\n    GenericSchema,\n    GenericTable,\n    GenericView,\n    PostgrestFilterBuilder,\n    SupabaseClient,\n    UseSupabaseGenerics,\n} from \"../types\";\nimport { globalOptions } from \"./index\";\n\n/**\n * Extends the Supabase client with additional functionality.\n *\n * This function overrides the `from` method of the Supabase client to return an `ExtendedQueryBuilder`.\n * The `ExtendedQueryBuilder` includes a `cache` method that allows setting a cache expiry time in seconds.\n * It also overrides the `select` method to include caching logic if caching is enabled and a cache provider is available.\n *\n * @param client - The original Supabase client to be extended.\n *\n * @returns An extended Supabase client with additional functionality.\n *\n * @template Schema - The schema type, defaults to `GenericSchema`.\n * @template Relation - The relation type, defaults to `GenericTable` or `GenericView`.\n * @template RelationName - The relation name type, defaults to `string`.\n * @template Relationships - The relationships type, defaults to an empty array.\n */\nexport function extendSupabaseClient<\n    Database,\n    SchemaName extends string &\n        keyof Database = UseSupabaseGenerics<Database>[\"SchemaName\"],\n    Schema extends GenericSchema = UseSupabaseGenerics<\n        Database,\n        SchemaName\n    >[\"Schema\"],\n>(\n    client: SupabaseClient<Database, SchemaName, Schema>,\n): ExtendedSupabaseClient<Database, SchemaName, Schema> {\n    // Store the original `from` method\n    const originalFrom = client.from;\n\n    // Override the `from` method\n    client.from = function <\n        TableName extends string,\n        Relation extends GenericTable | GenericView = GenericTable,\n        Relationships extends GenericRelationship[] = [],\n    >(\n        this: SupabaseClient<Database, SchemaName, Schema>, // Explicitly type `this` here\n        table: TableName,\n    ): ExtendedQueryBuilder<Schema, Relation, TableName, Relationships> {\n        // Call the original `from` method and cast the result\n        const queryBuilder = originalFrom.call(\n            this,\n            table,\n        ) as unknown as ExtendedQueryBuilder<\n            Schema,\n            Relation,\n            TableName,\n            Relationships\n        >;\n\n        // Add the `cache` method to the query builder\n        queryBuilder.cache = function (expireAfterSeconds: number) {\n            // Set the cache expiry time in seconds\n            this.expireAfterSeconds =\n                expireAfterSeconds > 0 ? expireAfterSeconds : 0;\n\n            // Return the query builder\n            return this;\n        };\n\n        // Store the original `select` method\n        const originalSelect = queryBuilder.select;\n\n        // Override the `select` method\n        queryBuilder.select = function <\n            Query extends string = \"*\",\n            // biome-ignore lint/suspicious/noExplicitAny: This is necessary to maximise support for different database schemas\n            ResultOne = any,\n        >(\n            columns?: Query,\n            options?: {\n                head?: boolean;\n                count?: null | \"exact\" | \"planned\" | \"estimated\";\n            },\n        ): PostgrestFilterBuilder<\n            Schema,\n            Relation[\"Row\"],\n            ResultOne,\n            TableName,\n            Relationships\n        > {\n            // If caching is enabled and a cache provider is available\n            if (\n                // Make sure the cache expiry time is set\n                typeof this.expireAfterSeconds === \"number\" &&\n                // Make sure the cache expiry time is greater than 0\n                this.expireAfterSeconds > 0 &&\n                // Make sure the cache provider is available\n                globalOptions.cache?.provider\n            ) {\n                // Intercept the global fetcher to inject custom headers\n                const existingFetch = this.fetch || fetch;\n\n                // Wrap the existing fetcher to add cache headers\n                const fetchWithCache: typeof fetch = async (\n                    input: RequestInfo | URL,\n                    init?: RequestInit,\n                ) => {\n                    // Add cache headers to the request\n                    const headers = {\n                        // Spread the existing headers\n                        ...(init?.headers || {}),\n\n                        // Add the relevant cache headers\n                        \"Cache-Control\": `public, max-age=${this.expireAfterSeconds}`,\n                        \"X-TTL\": `${this.expireAfterSeconds}`,\n                    };\n\n                    // Return the existing fetcher with the updated headers\n                    return existingFetch(input, { ...init, headers });\n                };\n\n                // Temporarily layer the fetcher for this query\n                this.fetch = fetchWithCache;\n\n                // Call the original `select` method and cast the result\n                return originalSelect.call(\n                    this,\n                    columns,\n                    options,\n                ) as PostgrestFilterBuilder<\n                    Schema,\n                    Relation[\"Row\"],\n                    ResultOne,\n                    TableName,\n                    Relationships\n                >;\n            }\n\n            // Default behavior if caching is not enabled\n            return originalSelect.call(\n                this,\n                columns,\n                options,\n            ) as PostgrestFilterBuilder<\n                Schema,\n                Relation[\"Row\"],\n                ResultOne,\n                TableName,\n                Relationships\n            >;\n        };\n\n        // Return the extended query builder\n        return queryBuilder;\n    } as unknown as SupabaseClient<Database, SchemaName, Schema>[\"from\"];\n\n    // Return the extended client\n    return client as unknown as ExtendedSupabaseClient<\n        Database,\n        SchemaName,\n        Schema\n    >;\n}\n"],
  "mappings": "oEA6BA,QAAA,qBAAAA,EAlBA,MAAAC,EAAA,QAAA,SAAA,EAkBA,SAAgBD,EASZE,EAAoD,CAGpD,MAAMC,EAAeD,EAAO,KAG5B,OAAAA,EAAO,KAAO,SAMVE,EAAgB,CAGhB,MAAMC,EAAeF,EAAa,KAC9B,KACAC,CAAK,EASTC,EAAa,MAAQ,SAAUC,EAA0B,CAErD,YAAK,mBACDA,EAAqB,EAAIA,EAAqB,EAG3C,IACX,EAGA,MAAMC,EAAiBF,EAAa,OAGpC,OAAAA,EAAa,OAAS,SAKlBG,EACAC,EAGC,CASD,GAEI,OAAO,KAAK,oBAAuB,UAEnC,KAAK,mBAAqB,GAE1BR,EAAA,cAAc,OAAO,SACvB,CAEE,MAAMS,EAAgB,KAAK,OAAS,MAG9BC,EAA+B,MACjCC,EACAC,IACA,CAEA,MAAMC,EAAU,CAEZ,GAAID,GAAM,SAAW,CAAA,EAGrB,gBAAiB,mBAAmB,KAAK,kBAAkB,GAC3D,QAAS,GAAG,KAAK,kBAAkB,IAIvC,OAAOH,EAAcE,EAAO,CAAE,GAAGC,EAAM,QAAAC,CAAO,CAAE,CACpD,EAGA,YAAK,MAAQH,EAGNJ,EAAe,KAClB,KACAC,EACAC,CAAO,CAQf,CAGA,OAAOF,EAAe,KAClB,KACAC,EACAC,CAAO,CAQf,EAGOJ,CACX,EAGOH,CAKX",
  "names": ["extendSupabaseClient", "index_1", "client", "originalFrom", "table", "queryBuilder", "expireAfterSeconds", "originalSelect", "columns", "options", "existingFetch", "fetchWithCache", "input", "init", "headers"]
}
